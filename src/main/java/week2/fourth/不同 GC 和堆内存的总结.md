# 不同 GC 和堆内存的总结

**串行gc**和并行gc在做gc垃圾回收的时候都是全栈业务停止的,jdk7/8都默认用的并行gc垃圾回收机制.就像我们现在做的业务系统,其实1g内存就够用了,现在大家都喜欢把系统做成微服务,一个服务如果太大了就拆分,所以很少有需要4g/8g或以上的运行内存支持,所以一般系统用jdk8默认的垃圾回收机制就够了.

为什么没有默认用串行gc?原因只有一个:因为是单线程的,但凡服务器内核是双核以上,它就显得效率低下了.它在新生代使用标记-复制算法,但要等这个操作做完了才去做其他操作,在full gc 的时候,老年代的标记-清除-整理算法,也需要等年轻代处理完了才能执行.导致gc暂停时间长.

**并行gc**就很好的解决了这个问题,并行gc在年轻代使用标记-复制算法的时候,老年代还可以执行标记-清除-整理算法,并且是可以多个线程一起处理的,如果是CPU是双核的,那它就比串行gc快至少4倍,因为它不仅可以多个线程一同进行gc,还可以进行流水线式的分工,总体用时短,且在业务程序执行期间不用维护gc相关的资源.如果你的业务系统需要更高的吞吐量,你可以使用并行gc.

**cms gc**相对于并行gc,只是在执行老年代gc的时候,为了防止过长的gc暂停而设计,让它能够在做老年代gc 的时候和业务线程并发执行,整个gc分为7步完成,其中只有两步需要gc暂停,且gc暂停的时间相当短.极大的减少老年代gc的暂停时间.但是和业务线程并发执行就不得不和业务线程抢资源,如果你的业务系统需要更小的延迟,你可以选择cms gc.

**G1 gc** 算是对cms gc的一个升级改造,g1 gc它的升级改造主要在于把垃圾回收的时间控制在一个可预期的范围之内,而且在g1 gc的策略中,将堆内存整个分成了大小等份的内存块,每个块可以被作为 新生区/垃圾区/老年代 ,它的设计目标主要是为了让我们的垃圾回收时间和我们的吞吐量之间达到一个平衡点.如果你需要高吞吐,那你可以将你的gc暂停的期望值设高一点.且在它的垃圾回收算法里面,会找出那些垃圾最多的内存块优先处理,整体来说效率也不低. 如果你的业务系统需要更灵活的在吞吐量和gc暂停之间做平衡,你可以选择cms gc